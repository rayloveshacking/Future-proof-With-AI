from django.shortcuts import render, redirect
from django.template import loader
from django.http import HttpResponse, JsonResponse
import os
from django.core.files.storage import default_storage
from django.conf import settings
import google.generativeai as genai
from pypdf import PdfReader
from docx import Document
import json # To parse potential JSON responses from Gemini

# Configure Gemini API
try:
    genai.configure(api_key=settings.GEMINI_API_KEY)
    gemini_model = genai.GenerativeModel('gemini-1.5-flash') # Or another suitable model
except AttributeError:
    print("Error: GEMINI_API_KEY not found in settings. Please add it.")
    gemini_model = None
except Exception as e:
    print(f"Error configuring Gemini: {e}")
    gemini_model = None

def extract_text_from_file(file_path):
    """Extracts text from PDF or DOCX files with robust error handling."""
    text = ""
    
    try:
        _, extension = os.path.splitext(file_path)
        extension = extension.lower()

        # PDF Handling
        if extension == '.pdf':
            try:
                with open(file_path, 'rb') as f:
                    reader = PdfReader(f)
                    for page in reader.pages:
                        page_text = page.extract_text()
                        if not page_text:
                            print(f"Warning: PDF page contains no extractable text (may be image-based)")
                        else:
                            text += page_text + "\n"
                    
                if not text.strip():
                    raise ValueError("PDF appears to be completely image-based or empty")
            except Exception as pdf_error:
                print(f"PDF processing error: {str(pdf_error)}")
                raise RuntimeError(f"PDF processing failed: {str(pdf_error)}") from pdf_error
                
        # DOCX Handling
        elif extension == '.docx':
            try:
                with open(file_path, 'rb') as f:
                    doc = Document(f)
                    for para in doc.paragraphs:
                        text += para.text + "\n"
                    
                if not text.strip():
                    raise ValueError("DOCX file appears to be empty")
            except Exception as docx_error:
                print(f"DOCX processing error: {str(docx_error)}")
                raise RuntimeError(f"DOCX processing failed: {str(docx_error)}") from docx_error
                
        # Unsupported file type
        else:
            raise ValueError(f"Unsupported file type: {extension}")

        return text

    except Exception as e:
        print(f"Error extracting text: {str(e)}")
        return None  # Return None to indicate extraction failure

def results(request):
    """Displays the results page with dynamic content generated by Gemini."""
    resume_text = request.session.get('resume_text')
    role = request.session.get('role')

    if not resume_text or not role:
        # Redirect to upload if session data is missing
        return redirect('upload') # Assuming 'upload' is the name of the upload URL pattern

    dynamic_content = {
        'role_title': role.replace('-', ' ').title(), # Basic title generation
        'roadmap': ["Define Goal", "Skill Assessment", "Learning Path", "Project Building", "Networking"], # Default
        'skills': {'Communication': 70, 'Teamwork': 65, 'Problem-Solving': 75, 'Adaptability': 60, 'Leadership': 50}, # Default
        'certifications': ["Generic Certification 1", "Generic Certification 2"] # Default
    }

    if gemini_model:
        try:
            # --- Prompt Gemini for Dynamic Content ---
            # Note: This is a basic prompt. Needs significant refinement for good results.
            # It asks for JSON output for easier parsing.
            prompt = f"""
            Analyze the following resume text for a candidate targeting the role of '{role}':
            --- RESUME START ---
            {resume_text}
            --- RESUME END ---

            Based *only* on the resume text and the target role, provide the following information in JSON format:
            1.  `role_title`: A suitable, formatted title for the results page (e.g., "AI-Enhanced {role}").
            2.  `roadmap`: A list of 4-6 key steps (strings) for a career roadmap towards this role, considering the resume's content.
            3.  `skills`: A dictionary of 5-7 relevant skills (keys as strings) and estimated proficiency levels (values as integers 0-100) based *only* on the resume.
            4.  `certifications`: A list of 3-5 relevant certifications or course types (strings) that would benefit this candidate for the target role, based on the resume.

            Output *only* the JSON object. Example format:
            {{
              "role_title": "Example Role Title",
              "roadmap": ["Step 1", "Step 2", "Step 3", "Step 4"],
              "skills": {{ "Skill A": 80, "Skill B": 75, "Skill C": 90 }},
              "certifications": ["Cert A", "Cert B", "Cert C"]
            }}
            """
            response = gemini_model.generate_content(prompt)

            # --- Parse Gemini Response ---
            # Basic parsing, needs robust error handling
            print(f"Gemini Raw Response:\n{response.text}") # Log the raw response for debugging
            try:
                # Clean potential markdown/code block formatting
                cleaned_response_text = response.text.strip().replace('```json', '').replace('```', '').strip()
                generated_data = json.loads(cleaned_response_text)

                # Validate and update dynamic_content (add checks for key existence and types)
                if isinstance(generated_data.get('role_title'), str):
                    dynamic_content['role_title'] = generated_data['role_title']
                if isinstance(generated_data.get('roadmap'), list):
                    dynamic_content['roadmap'] = generated_data['roadmap']
                if isinstance(generated_data.get('skills'), dict):
                    dynamic_content['skills'] = generated_data['skills']
                if isinstance(generated_data.get('certifications'), list):
                    dynamic_content['certifications'] = generated_data['certifications']

            except json.JSONDecodeError as json_e:
                print(f"Error decoding Gemini JSON response: {json_e}")
                print(f"Raw response was: {response.text}")
                # Keep default content if parsing fails
            except Exception as parse_e:
                print(f"Error processing Gemini response: {parse_e}")
                # Keep default content

        except Exception as e:
            print(f"Error calling Gemini API for dynamic content: {e}")
            # Use default content if API call fails

    # Prepare context for the template
    context = {
        'role_title': dynamic_content['role_title'],
        'roadmap_nodes_json': json.dumps(dynamic_content['roadmap']), # Pass roadmap as JSON string
        'skills_json': json.dumps(dynamic_content['skills']), # Pass skills as JSON for Chart.js
        'certifications': dynamic_content['certifications'],
        'resume_text_for_chat': resume_text # Pass resume text for chat context
    }
    template = loader.get_template('results.html')
    return HttpResponse(template.render(context, request))

def upload(request):
    """Handles file upload, text extraction, and redirects to results."""
    if request.method == 'POST':
        if 'file' not in request.FILES or 'role' not in request.POST:
             # Handle missing file or role
             return HttpResponse("Missing file or role.", status=400)

        file = request.FILES['file']
        role = request.POST['role']

        # Basic validation (add more robust checks)
        if not role:
            return HttpResponse("Role cannot be empty.", status=400)
        allowed_extensions = ['.pdf', '.docx']
        file_ext = os.path.splitext(file.name)[1].lower()
        if file_ext not in allowed_extensions:
             return HttpResponse(f"Unsupported file type: {file_ext}. Allowed: {', '.join(allowed_extensions)}", status=400)

        # Save the file temporarily
        file_path = default_storage.save(os.path.join(settings.MEDIA_ROOT, file.name), file)
        # Get absolute path using storage system
        full_file_path = default_storage.path(file_path)

        # Extract text with better error handling
        resume_text = extract_text_from_file(full_file_path)

        # Clean up the saved file after extraction
        try:
            if default_storage.exists(file_path):
                default_storage.delete(file_path)
        except Exception as e:
            print(f"Error deleting temporary file {file_path}: {e}")

        if resume_text is None:
            return HttpResponse("Could not extract text from the uploaded file. The file may be image-based, password-protected, or corrupted.", status=500)

        # Store extracted text and role in session
        request.session['resume_text'] = resume_text
        request.session['role'] = role
        request.session.save() # Explicitly save session

        return redirect('results') # Redirect to the results view
    else:
        # Display the upload form for GET requests
        template = loader.get_template('upload.html')
        return HttpResponse(template.render({}, request))

# --- New Chat View ---
def chat_with_gemini(request):
    """Handles AJAX chat requests using Gemini."""
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            user_message = data.get('message')
            resume_context = request.session.get('resume_text', '') # Get resume from session

            if not user_message:
                return JsonResponse({'error': 'Empty message received'}, status=400)

            if not gemini_model:
                 return JsonResponse({'reply': "Sorry, the AI chat model is not configured correctly."}, status=500)

            # --- Prompt Gemini for Chat Response ---
            # Include resume context in the prompt
            prompt = f"""
            You are a helpful career assistant chatbot. A user has uploaded their resume and is viewing an analysis.
            Their resume text is below:
            --- RESUME START ---
            {resume_context}
            --- RESUME END ---

            The user's message is: "{user_message}"

            Answer the user's question based *only* on the provided resume text. Be concise and helpful. If the question cannot be answered from the resume, say so politely. Do not make up information.
            """

            response = gemini_model.generate_content(prompt)
            ai_reply = response.text.strip()

            return JsonResponse({'reply': ai_reply})

        except json.JSONDecodeError:
            return JsonResponse({'error': 'Invalid JSON in request body'}, status=400)
        except Exception as e:
            print(f"Error in chat_with_gemini: {e}")
            # Provide a generic error response to the user
            return JsonResponse({'reply': f"Sorry, an error occurred while processing your chat message: {e}"}, status=500)
    else:
        # Handle non-POST requests (e.g., GET) if necessary, or return error
        return JsonResponse({'error': 'Only POST requests are allowed for chat'}, status=405)


def talent(request):
    template = loader.get_template('talent.html')
    return HttpResponse(template.render({}, request))
